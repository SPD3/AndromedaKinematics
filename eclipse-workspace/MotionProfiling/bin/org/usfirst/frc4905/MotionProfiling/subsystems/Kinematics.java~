// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4905.MotionProfiling.subsystems;

import java.util.ArrayDeque;

import org.usfirst.frc4905.MotionProfiling.Robot;
import org.usfirst.frc4905.MotionProfiling.RobotMap;
import org.usfirst.frc4905.MotionProfiling.commands.*;

import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * The equations described in this class can be found at:
 * http://www.physicsclassroom.com/Class/1DKin/U1L6b.cfm
 */
public class Kinematics extends Subsystem { 

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private double m_trajectoryPointInterval = 1;

	public class InvalidDimentionException extends Exception {
		/**
		 * I have no idea what that long is...
		 */
		private static final long serialVersionUID = 1L;

		public InvalidDimentionException(String message) {
			super(message);
		}
	}

	public class Path extends TrajectoryPaths {
		ArrayDeque<Point> setpointArray;
		double[] setpointMaxVelocityArray;

		ArrayDeque<Point> setpointArray2;
		double[] setpointMaxVelocityArray2;

		ArrayDeque<ArrayDeque<Point>> setpointArrays;
		double[][] setpointMaxVelocityArrays;

		int setPointDimention = 0;
	}

	private class TrajectoryPaths {
		double maxVelocity;
		double maxAcceleration;
		double maxJerk;
		public double getMaxVelocity() {return maxVelocity;};
		public double getmaxAcceleration() {return maxAcceleration;};

		ArrayDeque<TrajectoryPoint> trajectoryArray;

		ArrayDeque<TrajectoryPoint> trajectoryArray2;

		ArrayDeque<ArrayDeque<TrajectoryPoint>> trajectoryArrays;

		public ArrayDeque<TrajectoryPoint> getTrajectoryArray() {
			return trajectoryArray;
		}
	}

	public class TrajectoryPoint {
		public TrajectoryPoint(double currentVelocity, double acceleration, double position, double timestamp) {
			m_currentVelocity = currentVelocity;
			m_acceleration = acceleration;
			m_timestamp = timestamp;
			m_position = position;
		}

		public TrajectoryPoint() {

		}

		public double m_currentVelocity, m_acceleration, m_timestamp, m_position = 0.0;
		/*
		 * public double getm_CurrentVelocity() { return m_currentVelocity; } public
		 * double getm_Acceleration() { return m_acceleration; } public double
		 * getm_Timestamp() { return m_timestamp; }
		 */
	}

	public class Point {
		public Point(double x) {
			m_x = x;
			m_values = new double[1];
			m_values[0] = x;
			m_dim = 1;
		}

		public Point(double x, double y) {
			m_x = x;
			m_y = y;
			m_values = new double[2];
			m_values[0] = x;
			m_values[1] = y;
			m_dim = 2;
		}

		public int getDim() {
			return m_dim;
		}

		public double getm_X() {
			return m_x;
		}

		public double getm_Y() {
			return m_y;
		}

		double startCruisingDeltaTime;
		double endCruisingDeltaTime;
		double endDeltaTime;
		double maxVelocity;

		private double m_x, m_y = 0.0;
		private double[] m_values;
		private int m_dim;

		double vi = 0.0;
		double vf = 0.0;

	}

	/**
	 * Takes a point and tries to add it to the setpoint array inside of Key
	 */
	public void addPointToPath(Path Key, Point point) {
		try {
			privateAddPointToPath(Key, point, 0);
		} catch (InvalidDimentionException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Takes a point and tries to add it to the setpoint array inside of Key Takes
	 * the max velocity that the user wants and adds it to a max velocity array that
	 * will be used later on
	 */
	public void addPointToPath(Path Key, Point point, double maxVelocity) {
		try {
			privateAddPointToPath(Key, point, maxVelocity);
		} catch (InvalidDimentionException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Tries to add a point to the setpoint path inside of Key Throws an exception
	 * if the point is not the same dimension as all the other points inside of the
	 * setpoint array
	 */
	private void privateAddPointToPath(Path Key, Point point, double maxVelocity) throws InvalidDimentionException {
		// If the dimension of the path array has not been set yet set it to the
		// dimension of the point
		if (Key.setPointDimention == 0) {
			Key.setPointDimention = point.getDim();
			// If the dimension of the point does not match the dimension of the path array
			// throw an exception
		} else if (point.getDim() != point.getDim()) {
			String errMessage;
			if (point.getDim() == 1) {
				errMessage = "Point: (" + point.m_x + "," + point.m_y + ") is an invalid dimention.";
			} else {
				errMessage = "Point: (" + point.m_x + ") is an invalid dimention.";
			}
			InvalidDimentionException invalidDimentionException = new InvalidDimentionException(errMessage);
			throw invalidDimentionException;
		}

		Key.setpointArray.add(point);
		if (point.getDim() == 2) {
			splineFitNewPoints(Key);
		}
		Key.setpointMaxVelocityArray[Key.setpointMaxVelocityArray.length] = maxVelocity;
	}

	/**
	 * This method takes a two dimensional setpoint array and uses some sort of
	 * spline fitting to create a path from one setpoint to another
	 */
	private void splineFitNewPoints(Path Key) {

	}

	/**
	 * This method takes the setpoint array and turns it into a trajectory array by
	 * time parameterizing each setpoint
	 */
	@SuppressWarnings("null")
	public void createTrajectory(Path Key, double maxVelocity, double maxAcceleration, double maxJerk) {
		Key.maxAcceleration = maxAcceleration;
		Key.maxJerk = maxJerk;
		Key.maxVelocity = maxVelocity;

		/*
		 * If the dimension of the array is 2 numerically integrate the path to create
		 * two separate 1 dimensional paths Else add the another layer of array onto
		 * this setpoint array to keep everything uniform later on
		 */
		if (Key.setPointDimention == 2) {
			NumericallyIntegratePath(Key);
		} else {
			Key.setpointArrays.add(Key.setpointArray);
		}
		ArrayDeque<ArrayDeque<Point>> dynamicSetpointArrays = null;
		// For every setpoint array in the array of setpoint arrays
		for (int i = 0; i != Key.setpointArrays.size();) {
			ArrayDeque<Point> setpointArray = Key.setpointArrays.pop();
			double[] setpointMaxVelocityArray = Key.setpointMaxVelocityArrays[i];

			// Final velocity and Initial Velocity are commonly referred to as vi and vf
			// respectively
			getFinalVelocityAndInitialVelocity(setpointArray, setpointMaxVelocityArray, Key);

			// For every point in this setpoint array
			for (int i1 = 0; i1 != setpointArray.size();) {
				Point setpoint = setpointArray.pop();

				// Allows the user to customize the maximum velocity that they want for a
				// specific move in their path

				// THIS IS BROKEN
				if (setpointMaxVelocityArray[setpointMaxVelocityArray.length - setpointArray.size()] != 0
						&& setpointMaxVelocityArray[setpointMaxVelocityArray.length
								- setpointArray.size()] <= maxVelocity) {
					setpoint.maxVelocity = setpointMaxVelocityArray[i];
				} else {
					setpoint.maxVelocity = maxVelocity;
				}

				/*
				 * This equation pretend that the initial velocity and the final velocities are
				 * both 0, calculates the total distance covered if their was no velocity limit
				 * and then cuts that number in half in order to find the distance traveled at
				 * the peek of velocity before the trajectory starts to decelerate
				 */
				double theoreticalMaxVelocityDistance = ((Math.pow(setpoint.vi, 2) / (2 * Key.maxAcceleration)
						+ Math.pow(setpoint.vf, 2) / (2 * Key.maxAcceleration) + Math.abs(setpoint.m_x))) / 2;

				// This equation is the kinematic equation involving vf, vi, acceleration, and
				// displacement and has been rearranged to solve for vf
				double theoreticalMaxVelocity = Math
						.sqrt(Math.pow(setpoint.vi, 2) + 2 * Key.maxAcceleration * theoreticalMaxVelocityDistance);

				/*
				 * This equation is the kinematic equation involving vf, vi, acceleration and
				 * time and has been rearranged to solve for the time in which it will take to
				 * reach the theoretical max velocity
				 */
				double halfWayTime = (theoreticalMaxVelocity - setpoint.vi) / Key.maxAcceleration;

				/*
				 * If the theoretical max velocity is impossible to reach due to design
				 * constraints or user constraints that limit max velocity find when the max
				 * velocity will be reached and how long it will stay or "cruise" at that
				 * velocity before it needs to decelerate down to reach the vf
				 * 
				 * Else set the distance cruising to 0 and all the times associated with
				 * cruising to the halfway time which is when the maximum theoretical velocity
				 * will be reached and pretend that you are cruising for 0 seconds
				 */
				if (theoreticalMaxVelocity > Key.maxVelocity) {
					setpoint.startCruisingDeltaTime = (Key.maxVelocity - setpoint.vi) / Key.maxAcceleration;
					double endCruisingDeltaTimeFromEnd = Math
							.abs((setpoint.vf - Key.maxVelocity) / Key.maxAcceleration);
					double distanceAccelerating = getDistanceTraveledWhileAccelerating(setpoint.vi, Key.maxVelocity,
							Key.maxAcceleration);
					double distanceDecelerating = getDistanceTraveledWhileAccelerating(Key.maxVelocity, setpoint.vf,
							Key.maxAcceleration);
					double distanceCruising = setpoint.m_x - (distanceAccelerating + distanceDecelerating);
					setpoint.endCruisingDeltaTime = distanceCruising / Key.maxVelocity;
					setpoint.endDeltaTime = setpoint.endCruisingDeltaTime + endCruisingDeltaTimeFromEnd;
				} else {
					setpoint.startCruisingDeltaTime = halfWayTime;
					setpoint.endCruisingDeltaTime = halfWayTime;
					double endCruisingDeltaTimeFromEnd = Math
							.abs((setpoint.vf - theoreticalMaxVelocity) / Key.maxAcceleration);
					setpoint.endDeltaTime = setpoint.startCruisingDeltaTime + endCruisingDeltaTimeFromEnd;
				}

				// Needs to do this so that the last time through the code the max velocity is
				// not left at some obscure value
				Key.maxVelocity = maxVelocity;
			}
			dynamicSetpointArrays.add(setpointArray);
		}

		for (int i = 0; i != dynamicSetpointArrays.size();) {
			ArrayDeque<Point> setpointArray = dynamicSetpointArrays.pop();
			Key.setpointArrays.add(setpointArray);
		}
		setTrajectoryArray(Key);

	}

	/**
	 * This is where the left and right wheels are split into two different paths
	 */
	private void NumericallyIntegratePath(Path Key) {
		Key.setpointArrays.add(Key.setpointArray);
		Key.setpointArrays.add(Key.setpointArray2);

		Key.setpointMaxVelocityArrays[0] = Key.setpointMaxVelocityArray;
		Key.setpointMaxVelocityArrays[1] = Key.setpointMaxVelocityArray2;
	}

	/**
	 * This method uses takes all the setpoints and finds the vi and vf for each of
	 * them
	 */
	// I don't know what this means...
	@SuppressWarnings("null")
	private void getFinalVelocityAndInitialVelocity(ArrayDeque<Point> setpointArray, double[] setpointMaxVelocityArray,
			Path Key) {
		int initialSetpointArraySize = setpointArray.size();
		// This is a storage place for all of the points that get popped off of the
		// original setpoint array
		ArrayDeque<Point> dynamicSetpointArray = null;

		// For every point inside of the setpoint array
		for (int i1 = 0; i1 != setpointArray.size();) {
			boolean traveledInAPositiveDirection;
			boolean willTravelInAPositiveDirection;
			Point setpoint = setpointArray.pop();

			/*
			 * If this is the first setpoint being looked at set the vi to 0.0
			 * 
			 * Else set vi to the vf of the last setpoint looked at
			 */
			if (setpointArray.size() == (initialSetpointArraySize - 1)) {
				setpoint.vi = 0.0;
			} else {
				setpoint.vi = dynamicSetpointArray.getLast().vf;
			}

			/*
			 * If this is the first setpoint being looked at set
			 * traveledInAPositiveDirection according to whether or not setpoint is positive
			 * or negative
			 * 
			 * Else if the setpoint is greater than the last setpoint set
			 * traveledInAPositiveDirection to true
			 * 
			 * Else set traveledInAPositiveDirection to false
			 */
			if (setpointArray.size() == (initialSetpointArraySize - 1)) {
				if (setpoint.m_x > 0) {
					traveledInAPositiveDirection = true;
				} else {
					traveledInAPositiveDirection = false;
				}
			} else if (setpoint.m_x > dynamicSetpointArray.getLast().m_x) {
				traveledInAPositiveDirection = true;
			} else {
				traveledInAPositiveDirection = false;
			}

			/*
			 * If this is the very last setpoint willTravelInAPositiveDirection does not
			 * matter so set it to false
			 * 
			 * Else if this setpoint is greater than the next setpoint set
			 * willTravelInAPositiveDirection to false
			 * 
			 * Else set willTravelInAPositiveDirection to true
			 */
			if (setpointArray.size() == 0) {
				willTravelInAPositiveDirection = false;
			} else if (setpoint.m_x > setpointArray.element().m_x) {
				willTravelInAPositiveDirection = false;
			} else {
				willTravelInAPositiveDirection = true;
			}

			/*
			 * If this is the final setpoint in the array you want the final velocity to be
			 * 0 so set vf to 0
			 * 
			 * Else if you have been traveling in a positive direction and you will continue
			 * traveling in a positive direction or you have been traveling in a negative
			 * direction and you will continue traveling in a negative direction calculate
			 * whether or not you have to slow down when going to the current setpoint in
			 * order to prepare to reach the other setpoints
			 * 
			 * Else you will be reversing direction so your vf will be 0.0
			 */
			if (setpointArray.size() == 0) {
				setpoint.vf = 0.0;
			} else if ((traveledInAPositiveDirection && willTravelInAPositiveDirection)
					|| (!traveledInAPositiveDirection && !willTravelInAPositiveDirection)) {
				/*
				 * This max velocity reachable is different from the theoretical max velocity
				 * reachable back in the method createTrajectory because it does account for the
				 * max velocity either specified inside of Key or inside of the maximum velocity
				 * array
				 */
				double maxVelocityReachable;
				double distanceTraveledWhileAcceleratingToMaxVelocity;

				/*
				 * If the max velocity specified is valid use it to find the distance traveled
				 * while accelerating
				 * 
				 * Else use the max velocity specified inside of Key
				 */

				// What if this is the first point???!!!!????!!!
				if (setpointMaxVelocityArray[(initialSetpointArraySize - setpointArray.size() - 1)] != 0
						&& setpointMaxVelocityArray[(initialSetpointArraySize
								- setpointArray.size())] < Key.maxVelocity) {
					distanceTraveledWhileAcceleratingToMaxVelocity = getDistanceTraveledWhileAccelerating(
							dynamicSetpointArray.getLast().vf,
							setpointMaxVelocityArray[(initialSetpointArraySize - setpointArray.size())],
							Key.maxAcceleration);
				} else {
					// PROBLEM!!!!
					distanceTraveledWhileAcceleratingToMaxVelocity = getDistanceTraveledWhileAccelerating(
							dynamicSetpointArray.getLast().vf, Key.maxVelocity, Key.maxAcceleration);
				}

				/*
				 * If the distance traveled while accelerating up to max velocity is not past
				 * the setpoint set maxVelocityReachable to the max velocity either specified
				 * inside of Key or in the max velocity array
				 * 
				 * Else assign it to the final velocity reached during the process of
				 * accelerating to the setpoint
				 */
				if (distanceTraveledWhileAcceleratingToMaxVelocity < ((Math
						.abs(setpoint.m_x - setpointArray.peekFirst().m_x) / 2))) {
					if (setpointMaxVelocityArray[(initialSetpointArraySize - setpointArray.size() - 1)] != 0
							&& setpointMaxVelocityArray[(initialSetpointArraySize
									- setpointArray.size())] < Key.maxVelocity) {
						maxVelocityReachable = setpointMaxVelocityArray[(initialSetpointArraySize
								- setpointArray.size())];
					} else {
						maxVelocityReachable = Key.maxVelocity;
					}
				} else {
					// This equation is the kinematic equation involving vf, vi, acceleration, and
					// displacement and has been rearranged to solve for vf
					maxVelocityReachable = Math.sqrt(Math.pow(dynamicSetpointArray.getLast().vf, 2)
							+ 2 * Key.maxAcceleration * (setpoint.m_x - setpointArray.peekFirst().m_x));
				}
				getVfForPoint(setpoint, setpointArray, willTravelInAPositiveDirection, maxVelocityReachable,
						Key.maxAcceleration, setpointMaxVelocityArray, Key.maxVelocity);

			} else {
				setpoint.vf = 0.0;
			}

			// Store the point away in another array so that they can be transfered back to
			// the original setpoint array
			dynamicSetpointArray.add(setpoint);
		}
		for (int i1 = 0; i1 != dynamicSetpointArray.size();) {
			Point point = dynamicSetpointArray.pop();
			setpointArray.add(point);
		}
	}

	// WHAT DOES THIS MEAN??? THERE IS ANOTHER ONE OF THESE
	@SuppressWarnings("null")
	/**
	 * This method takes a point and looks at the next setpoint(s) in order to
	 * determine the final velocity of the original point
	 * 
	 * 
	 */
	private void getVfForPoint(Point setpoint, ArrayDeque<Point> setpointArray, Boolean travelingInPositiveDirection,
			double maxVelocityReachable, double maxAcceleration, double[] maxVelocityArray, double maxVelocity) {
		// This array is a temporary storage spot for points that are popped off the end
		// of the original setpoint Array
		ArrayDeque<Point> dynamicSetpointArray = null;

		double distanceTraveledWhileAcceleratingFrom0ToMaxVelocityReachable = getDistanceTraveledWhileAccelerating(0.0,
				maxVelocityReachable, maxAcceleration);

		Point lastSetpoint = new Point(0, 0);

		setpoint.vf = maxVelocityReachable + 1.0;
		if (travelingInPositiveDirection) {

			for (double i = setpointArray
					.peekFirst().m_x; i < distanceTraveledWhileAcceleratingFrom0ToMaxVelocityReachable
							+ setpoint.m_x;) {
				Point nextSetpoint = setpointArray.pop();
				// This breaks on the last point

				// Check all the code to see what happens on first and last points...
				double nextSetpointMaxVelocity = maxVelocityArray[maxVelocityArray.length - setpointArray.size()];

				if (nextSetpoint.m_x < lastSetpoint.m_x) {
					double tempVf = Math.sqrt(-2 * maxAcceleration * (nextSetpoint.m_x - setpoint.m_x));
					if (tempVf < setpoint.vf) {
						setpoint.vf = tempVf;
					}
					dynamicSetpointArray.add(nextSetpoint);
					break;
				}
				if (nextSetpointMaxVelocity == 0.0 || nextSetpointMaxVelocity >= maxVelocityReachable) {
					setpoint.vf = maxVelocityReachable;
				} else if (0.0 < nextSetpointMaxVelocity && nextSetpointMaxVelocity < maxVelocityReachable) {
					double distanceTraveledWhileAcceleratingFromMaxVelocityReachableToNextSetpointMaxVelocity = getDistanceTraveledWhileAccelerating(
							nextSetpointMaxVelocity, maxVelocityReachable, maxAcceleration);
					if (distanceTraveledWhileAcceleratingFromMaxVelocityReachableToNextSetpointMaxVelocity < (setpoint.m_x
							- nextSetpoint.m_x)) {
						setpoint.vf = maxVelocityReachable;
					} else {
						double tempVf = Math.sqrt(Math.pow(nextSetpointMaxVelocity, 2)
								- 2 * maxAcceleration * (nextSetpoint.m_x - setpoint.m_x));
						if (tempVf < setpoint.vf) {
							setpoint.vf = tempVf;
						}
					}
				}
				dynamicSetpointArray.add(nextSetpoint);
				nextSetpoint = lastSetpoint;
			}
			for (int i = 0; i != setpointArray.size();) {
				Point nextSetpoint = setpointArray.pop();
				dynamicSetpointArray.add(nextSetpoint);
			}
			for (int i = 0; i != dynamicSetpointArray.size();) {
				Point nextSetpoint = dynamicSetpointArray.pop();
				setpointArray.add(nextSetpoint);
			}
		}
	}

	/**
	 * This method uses the kinematic equation involving vi, vf, acceleration and
	 * displacement to get distance traveled while accelerating
	 */
	private double getDistanceTraveledWhileAccelerating(double vi, double vf, double maxAcceleration) {
		double distance = Math.abs((Math.pow(vf, 2) - Math.pow(vi, 2)) / (2 * maxAcceleration));
		return distance;
	}

	/**
	 * This method uses the trajectory parameters set inside of key to create a
	 * matrix in which current velocity, acceleration, position and timestamps are
	 * stored
	 */
	private void setTrajectoryArray(Path Key) {
		if (Key.setpointArrays.size() == 2) {
			Key.trajectoryArrays.add(Key.trajectoryArray);
			Key.trajectoryArrays.add(Key.trajectoryArray2);
		} else {
			Key.trajectoryArrays.add(Key.trajectoryArray);
		}
		for (int i = 0; i != Key.setpointArrays.size();) {
			ArrayDeque<Point> setpointArray = Key.setpointArrays.pop();
			ArrayDeque<TrajectoryPoint> trajectoryArray = Key.trajectoryArrays.pop();
			for (int i1 = 0; i1 != setpointArray.size();) {
				Point setpoint = setpointArray.pop();
				for (double i11 = 0; i11 <= setpoint.endDeltaTime; i11 += m_trajectoryPointInterval) {
					TrajectoryPoint trajectoryPoint = new TrajectoryPoint(0, 0, 0, i11);
					if (setpoint.startCruisingDeltaTime <= i11 && i11 <= setpoint.endCruisingDeltaTime) {
						trajectoryPoint.m_currentVelocity = Key.maxVelocity;
						double distanceTraveledWhileAccelerating = getDistanceTraveledWhileAccelerating(setpoint.vi,
								setpoint.maxVelocity, Key.maxAcceleration);
						double distanceTraveledWhileCruising = setpoint.maxVelocity
								* (i11 - setpoint.startCruisingDeltaTime);
						trajectoryPoint.m_position = distanceTraveledWhileAccelerating + distanceTraveledWhileCruising;
					} else if (i11 < setpoint.startCruisingDeltaTime) {
						trajectoryPoint.m_currentVelocity = Key.maxAcceleration * i11;
						trajectoryPoint.m_position = getDistanceTraveledWhileAccelerating(setpoint.vi,
								trajectoryPoint.m_currentVelocity, Key.maxAcceleration);
					} else {
						trajectoryPoint.m_currentVelocity = Key.maxAcceleration * (setpoint.endDeltaTime - i11);
						double distanceTraveledWhileAccelerating = getDistanceTraveledWhileAccelerating(setpoint.vi,
								setpoint.maxVelocity, Key.maxAcceleration);
						double distanceTraveledWhileCruising = setpoint.maxVelocity
								* (setpoint.endCruisingDeltaTime - setpoint.startCruisingDeltaTime);
						double distanceTraveledWhileDecelerating = getDistanceTraveledWhileAccelerating(
								setpoint.maxVelocity, trajectoryPoint.m_currentVelocity, Key.maxAcceleration);
						trajectoryPoint.m_position = distanceTraveledWhileAccelerating + distanceTraveledWhileCruising
								+ distanceTraveledWhileDecelerating;
					}
					double nextTime = i11 + m_trajectoryPointInterval;
					double nextVelocity;
					if (setpoint.startCruisingDeltaTime <= nextTime && nextTime <= setpoint.endCruisingDeltaTime) {
						nextVelocity = Key.maxVelocity;
					} else if (nextTime < setpoint.startCruisingDeltaTime) {
						nextVelocity = Key.maxAcceleration * nextTime;
					} else {
						nextVelocity = Key.maxAcceleration * (setpoint.endDeltaTime - nextTime);
					}
					trajectoryPoint.m_acceleration = nextVelocity - trajectoryPoint.m_currentVelocity;
					trajectoryArray.add(trajectoryPoint);
				}
			}
			Key.trajectoryArrays.add(trajectoryArray);
		}
	}

	public static TrajectoryPoint getTrajectoryPoint(ArrayDeque<TrajectoryPoint> trajectoryPath, double deltaTime) {
		TrajectoryPoint point = Robot.kinematics.new TrajectoryPoint();
		ArrayDeque<TrajectoryPoint> dynamicTrajectoryPath = new ArrayDeque<TrajectoryPoint>();
		for (int i = 0; i < trajectoryPath.size();) {
			point = trajectoryPath.pop();
			dynamicTrajectoryPath.add(point);
			if (point.m_timestamp >= deltaTime) {
				for (int i1 = 0; i1 < trajectoryPath.size();) {
					point = trajectoryPath.pop();
					dynamicTrajectoryPath.add(point);
				}
				for (int i1 = 0; i1 < dynamicTrajectoryPath.size();) {
					point = dynamicTrajectoryPath.pop();
					trajectoryPath.add(point);
				}
				return point;
			}
		}
		return point;
	}

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}
}
