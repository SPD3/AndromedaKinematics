// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4905.MotionProfiling.commands;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;

import java.util.Vector;

import org.usfirst.frc4905.MotionProfiling.Robot;

import Utilities.Trace;

/**
 *
 */
public class RunWheelsAndLog extends Command {
	Vector<String> m_header = new Vector<String>();
	double m_initialTimeStamp = 0.0;
	double m_previousVelocity = 0.0;
	double m_previousTimeStamp = 0.0;
	double m_totalDeltaTimeFromLastExecute;
	double m_numberofDeltaTimesFromLastExecute;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public RunWheelsAndLog() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		
		Vector<String> header = new Vector<String>();
		header.add(new String("Velocities"));
		header.add(new String("Acceleration"));
		header.add(new String("Position"));
		Trace.getInstance().addTrace("MotionProfilingData", header);
		m_header = header;
		m_initialTimeStamp = Timer.getFPGATimestamp();
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
<<<<<<< HEAD
		Robot.driveTrain.setControlModePercentVbus();
		Robot.driveTrain.setAllDriveControllers(0.2);
		
=======
		Robot.driveTrain.setAllDriveControllers(0.1);

>>>>>>> JerkTesting
		Vector<Double> entry = new Vector<Double>();
		double currentTimeStamp = Timer.getFPGATimestamp();
		double deltaTimeFromLastExecute = currentTimeStamp - m_previousTimeStamp;

		double deltaTime = currentTimeStamp - m_previousTimeStamp;
		deltaTime /= 60;
		double currentVelocity = Robot.driveTrain.getVelocity();
		double currentAcceleration = currentVelocity - m_previousVelocity;
		currentAcceleration /= deltaTime;
		
		m_totalDeltaTimeFromLastExecute+=deltaTimeFromLastExecute;
		m_numberofDeltaTimesFromLastExecute++;
		entry.add(new Double(currentVelocity));
		entry.add(new Double(currentAcceleration));
		entry.add(new Double(Robot.driveTrain.getEncoderPosition()));
		
		
		Trace.getInstance().addEntry("MotionProfilingData", entry);
		// 0 Sep 28 19:48 MotionProfilingData09-28-2017-19-48-27.csv

		m_previousTimeStamp = currentTimeStamp;
		m_previousVelocity = currentVelocity;
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.driveTrain.setAllDriveControllers(0.0);
<<<<<<< HEAD
		Trace.getInstance().flushTraceFiles();
		
=======
>>>>>>> JerkTesting
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}
}
